import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import statsmodels.api as sm
from scipy.stats import pearsonr

# Load the dataset
file_path = r"C:\Users\nPr\PycharmProjects\pythonProject1\racial_smv_example_data.csv"
data = pd.read_csv(file_path)

# Define the rating columns (assuming columns 0 to 20 contain the ratings)
rating_columns = [str(i) for i in range(20)]

# Replace 0 with NaN and impute missing values
for col in rating_columns:
    data[col] = pd.to_numeric(data[col], errors='coerce')  # Ensure numeric type
    data[col] = data[col].apply(lambda x: np.nan if x == 0 else x)  # Replace 0 with NaN
    data[col] = data[col].fillna(data[col].mean())  # Fill NaN with mean

# Male group to FST mapping based on Swedish data, with fallback to Finnish values
fst_mapping = {
    'arab men': 0.0191,  # Palestinians-Swedish average
    'asian men': 0.110,  # Approximation from Finnish data (fallback)
    'african men': 0.179,  # Yoruba (from Finnish fallback)
    'latino men': 0.0048,  # Spanish-Swedish average
    'russian men': 0.0033,  # Russians-Swedish average
    'italian men': 0.0012,  # Italians-Swedish average
    'german men': 0.0009,  # Germans-Swedish average
    'australian men': 0.0007,  # British (from Finnish fallback)
    'american men': 0.0007   # British (From Finnish fallback)
}

# Filter data for Northern European women
northern_groups = ['nordic women', 'german women', 'other white women', 'french women']
northern_ratings = data[data['Women'].isin(northern_groups)]

# Group by male groups and calculate average ratings across Northern European women
northern_avg_ratings = (
    northern_ratings
    .groupby('Men')
    .mean(numeric_only=True)  # Ensure only numeric columns are included
    .mean(axis=1)  # Average across all rating columns
    .sort_values()  # Sort by ascending ratings
)

# Create a results DataFrame with male groups and average ratings
northern_results = pd.DataFrame({
    'Men': northern_avg_ratings.index,
    'Average Rating': northern_avg_ratings.values
})

# Map updated FST values to the male groups
northern_results['FST'] = northern_results['Men'].map(fst_mapping)

# Calculate the correlation between genetic distance and average ratings
correlation, p_value = pearsonr(northern_results['FST'], northern_results['Average Rating'])

# Print correlation results
print(f"Correlation between genetic distance and average ratings: {correlation:.2f}")
print(f"P-value: {p_value:.3f}")

# Visualize the relationship
plt.figure(figsize=(8, 6))
sns.scatterplot(data=northern_results, x='FST', y='Average Rating', hue='Men', palette='dark', style='Men', s=100)
plt.title('Genetic Distance (FST) vs. Average Rating (Northern European Women)')
plt.xlabel('Genetic Distance')
plt.ylabel('Average Rating')
plt.gca().invert_yaxis()
plt.axhline(northern_results['Average Rating'].mean(), color='red', linestyle='--', label='Mean Rating')
plt.legend()
plt.show()

# Filter relevant columns
clustering_features = northern_results[['FST', 'Average Rating']].dropna()

# Add a quadratic term for FST
clustering_features['FST^2'] = clustering_features['FST'] ** 2

# Fit a quadratic regression model
X = clustering_features[['FST', 'FST^2']]
y = clustering_features['Average Rating']
X = sm.add_constant(X)  # Add intercept term
model = sm.OLS(y, X).fit()

# Step 3: Visualize the relationship
plt.figure(figsize=(8, 6))
sns.scatterplot(data=clustering_features, x='FST', y='Average Rating', s=100)

# Generate predictions for visualization
fst_range = np.linspace(clustering_features['FST'].min(), clustering_features['FST'].max(), 100)
predicted_ratings = model.predict(sm.add_constant(pd.DataFrame({'FST': fst_range, 'FST^2': fst_range ** 2})))

# Plot the quadratic fit
plt.plot(fst_range, predicted_ratings, color='red', label='Quadratic Fit')

# Add labels and title
plt.title('Genetic Distance vs. Average Rating (Northern European Women)')
plt.xlabel('Genetic Distance (FST)')
plt.ylabel('Average Rating')
plt.gca().invert_yaxis()  # Invert y-axis since lower ratings are better
plt.legend()
plt.show()

# Exclude Asian and African male groups to reduce variance in genetic distance
filtered_clustering_features = clustering_features[~northern_results['Men'].isin([])]

# Re-run the quadratic regression with the filtered dataset
X_filtered = filtered_clustering_features[['FST', 'FST^2']]
y_filtered = filtered_clustering_features['Average Rating']
X_filtered = sm.add_constant(X_filtered)  # Add intercept term
filtered_model = sm.OLS(y_filtered, X_filtered).fit()

# Generate predictions for the filtered model
fst_range_filtered = np.linspace(filtered_clustering_features['FST'].min(), filtered_clustering_features['FST'].max(), 100)
predicted_ratings_filtered = filtered_model.predict(
    sm.add_constant(pd.DataFrame({'FST': fst_range_filtered, 'FST^2': fst_range_filtered ** 2}))
)

# Find the optimal FST in the filtered model
optimal_fst_filtered = fst_range_filtered[np.argmin(predicted_ratings_filtered)]
optimal_rating_filtered = np.min(predicted_ratings_filtered)

# Display the new sweet spot
print(f"Filtered Optimal Genetic Distance (FST): {optimal_fst_filtered:.4f}")
print(f"Predicted Rating at Sweet Spot: {optimal_rating_filtered:.2f}")

# Visualize the filtered sweet spot on the graph
plt.figure(figsize=(8, 6))
sns.scatterplot(data=filtered_clustering_features, x='FST', y='Average Rating', s=100)
plt.plot(fst_range_filtered, predicted_ratings_filtered, color='red', label='Quadratic Fit (Filtered)')
plt.scatter(optimal_fst_filtered, optimal_rating_filtered, color='blue', s=150, label='Filtered Sweet Spot')  # Highlight sweet spot
plt.title('Genetic Distance vs. Average Rating (Filtered)')
plt.xlabel('Genetic Distance (FST)')
plt.ylabel('Average Rating')
plt.gca().invert_yaxis()  # Invert y-axis since lower ratings are better
plt.legend()
plt.show()


# Updated weights
weights = {
    'nordic women': 10,
    'other white women': 6,
    'german women': 8,
    'russian women': 4,
    'other slavic women': 5,
    'french women': 7,
    'spanish women': 1,
    'italian women': 3,
    'balkan women': 2,
}


# Map weights to the dataset
data['Weight'] = data['Women'].map(weights)

# Compute weighted average for each male group
def compute_weighted_avg(group):
    # Multiply ratings by weights, then average
    weighted_avg = np.average(
        group.iloc[:, 2:-1],  # Select rating columns
        weights=group['Weight'],
        axis=0
    )
    return np.mean(weighted_avg)  # Return mean of weighted averages

weighted_ranking = (
    data.groupby('Men')
    .apply(compute_weighted_avg)
    .sort_values()
)

# Display the ranked male groups
print(weighted_ranking)
